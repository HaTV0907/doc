<!DOCTYPE html>
<!-- saved from url=(0048)https://ops.tips/blog/how-linux-creates-sockets/ -->
<html lang="en"><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>How Linux creates sockets and counts them | OpsTips</title>

<link rel="amphtml" type="text/html" href="https://ops.tips/amp/blog/how-linux-creates-sockets/">



<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="theme-color" content="#ffffff">
<meta name="description" content="A deep dive into what goes under the hood in the Linux kernel when you can the socket system call">
<meta name="author" content="Ciro S. Costa">
<meta name="keywords" content="linux, kernel, procfs, networking, sockets">

<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@cirowrc">
<meta name="twitter:site" content="@cirowrc">


<meta property="og:title" content="How Linux creates sockets and counts them">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ops.tips/blog/how-linux-creates-sockets">
<meta property="og:image" content="https://ops.tips/blog/-/images/slash-proc.png">
<meta property="og:image:alt" content="Article image">
<meta property="og:description" content="A deep dive into what goes under the hood in the Linux kernel when you can the socket system call">
<meta property="og:site_name" content="OpsTips">


<meta property="article:author" content="Ciro S. Costa">
<meta property="article:published_time" content="2018-10-16T00:00:00+0000">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="networking">


<meta name="google-site-verification" content="nJDg4CxanyHivDq4bwex7CwpV4qc2rpDW-PCr0HfsX8">

<link rel="feed" href="https://ops.tips/index.xml" type="application/rss+xml" title="OpsTips">
<link rel="shortcut icon" href="https://ops.tips/favicon.ico">

    <script type="text/javascript" async="" src="./How Linux creates sockets and counts them _ OpsTips_files/analytics.js.tải xuống"></script><script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "NewsArticle",
  "articleSection" : "blog",
  "name" : "How Linux creates sockets and counts them",
  "headline" : "How Linux creates sockets and counts them",
  "description" : "A deep dive into what goes under the hood in the Linux kernel when you can the socket system call",
  "inLanguage" : "en-US",
  "author": {
    "@type": "Person",
    "name": "Ciro S. Costa",
    "sameAs": [
        "https://twitter.com/cirowrc",
        "https://www.linkedin.com/in/cirocosta/",
        "https://github.com/cirocosta"
    ],
    "image": {
      "@type": "ImageObject",
      "url": "https:\/\/ops.tips\/blog/-/images/slash-proc.png",
      "width": 800,
      "height": 800
    }
  },
  "creator": {
    "@type": "Person",
    "name": "Ciro S. Costa",
    "sameAs": [
        "https://twitter.com/cirowrc",
        "https://www.linkedin.com/in/cirocosta/",
        "https://github.com/cirocosta"
    ],
    "image": {
      "@type": "ImageObject",
      "url": "https:\/\/ops.tips\/me.jpg",
      "width": 800,
      "height": 800
    }
  },
  "accountablePerson": {
    "@type": "Person",
    "name": "Ciro S. Costa",
    "sameAs": [
        "https://twitter.com/cirowrc",
        "https://www.linkedin.com/in/cirocosta/",
        "https://github.com/cirocosta"
    ],
    "image": {
      "@type": "ImageObject",
      "url": "https:\/\/ops.tips\/me.jpg",
      "width": 800,
      "height": 800
    }
  },
  "copyrightHolder": {
    "@type": "Person",
    "name": "Ciro S. Costa",
    "sameAs": [
        "https://twitter.com/cirowrc",
        "https://www.linkedin.com/in/cirocosta/",
        "https://github.com/cirocosta"
    ],
    "image": {
      "@type": "ImageObject",
      "url": "https:\/\/ops.tips\/me.jpg",
      "width": 800,
      "height": 800
    }
  },
  "copyrightYear" : "2018",
  "datePublished" : "2018-10-16T00:00:00\x2b0000",
  "dateModified" : "2018-10-16T00:00:00\x2b0000",
  "publisher": {
    "@type": "Organization",
    "name": "ops.tips",
    "url" : "https:\/\/ops.tips\/",
    "logo": {
      "@type": "ImageObject",
      "url": "https:\/\/ops.tips\/opstips.png"
    }
  },
  "wordCount" : "2940",
  "image": {
    "@type": "ImageObject",
    "url": "https:\/\/ops.tips\/blog/-/images/slash-proc.png",
    "width": 1200,
    "height": 1200
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https:\/\/ops.tips\/blog/how-linux-creates-sockets"
  },
  "keywords" : [ "linux", "kernel", "procfs", "networking", "sockets" ]
}
</script>

  <script charset="utf-8" src="./How Linux creates sockets and counts them _ OpsTips_files/moment_timeline_tweet.059acc8fc49c0c7de73607b3bbd326e2.js.tải xuống"></script><script charset="utf-8" src="./How Linux creates sockets and counts them _ OpsTips_files/tweet.73b7ab8a56ad3263cad8d36ba66467fc.js.tải xuống"></script><script src="./How Linux creates sockets and counts them _ OpsTips_files/12e7973d11b242a861.js.tải xuống"></script><script type="text/javascript" src="./How Linux creates sockets and counts them _ OpsTips_files/l.js.tải xuống"></script><script type="text/javascript" src="./How Linux creates sockets and counts them _ OpsTips_files/api"></script><script type="text/javascript" src="./How Linux creates sockets and counts them _ OpsTips_files/12e7973d11b242a861.js(1).tải xuống"></script><script type="text/javascript" src="./How Linux creates sockets and counts them _ OpsTips_files/script.js.tải xuống"></script><script async="" type="text/javascript" src="./How Linux creates sockets and counts them _ OpsTips_files/pops"></script><script type="text/javascript" src="./How Linux creates sockets and counts them _ OpsTips_files/license.14.js.tải xuống"></script></head>

  <body class="article">
    <main class="main">

  <header>
    <h1 itemprop="name headline">How Linux creates sockets and counts them</h1>
    <h2 itemprop="description">A deep dive into what goes under the hood in the Linux kernel when you can the socket system call</h2>

    <aside>
      <p>
        by <a href="https://twitter.com/cirowrc">Ciro S. Costa</a> -
        <time datetime="2018-10-16T00:00:00+0000" itemprop="datePublished">
          Oct 16, 2018
        </time>
      </p>

      
        <p>
          tags:

          
            <a href="https://ops.tips/tags/linux">
              linux
            </a>
          , 
            <a href="https://ops.tips/tags/networking">
              networking
            </a>
          
        </p>
      

    </aside>
  </header>

  <article itemtype="http://schema.org/NewsArticle">
    <section class="article-body" itemprop="articleBody">
      

<p>Hey,</p>

<p>If you’ve been working with web servers for a little while, you certainly have already hit the classic “<em>address already in use</em>” (EADDRINUSE).</p>

<p>Here in this article, we go through not only how to see whether such condition as conditioned to happen (by looking at the list of open sockets), but also verify in the actual Kernel code paths where that check happens.</p>

<figure class="expanded-container">
  <img width="100%" height="100%" style="max-width: 65rem; " src="./How Linux creates sockets and counts them _ OpsTips_files/socket-how-does-it-work.svg" alt="Illustration of someone wondering about how does the socket syscall work ">

  
</figure>


<p>In case you’ve been wondering about how the <a href="http://man7.org/linux/man-pages/man2/socket.2.html" target="_blank"><code>socket(2)</code></a> syscall works where are these sockets stored, make sure you stick to the end!</p>

<div class="ps">

<p>This is the sixth article in a series of 30 articles around <em>procfs</em>: <a href="https://ops.tips/blog/a-month-of-proc/">A Month of /proc</a>.</p>

<p>If you’d like to keep up to date with it, make sure you <a href="https://google.us3.list-manage.com/subscribe/post?u=1941019739d6aa1a25eda3787&amp;id=ff9c3cc11e" target="_blank"><strong>join the mailing list</strong></a>!</p>

</div>


<!-- START doctoc generated TOC please keep comment here to allow auto update -->

<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

<ul>
<li><a href="https://ops.tips/blog/how-linux-creates-sockets/#what-are-these-sockets-about">What are these sockets about?</a></li>
<li><a href="https://ops.tips/blog/how-linux-creates-sockets/#where-to-look-for-the-list-of-sockets-in-my-system">Where to look for the list of sockets in my system?</a></li>
<li><a href="https://ops.tips/blog/how-linux-creates-sockets/#what-happens-under-the-hood-when-the-socket-syscall-gets-called">What happens under the hood when the socket syscall gets called?</a></li>
<li><a href="https://ops.tips/blog/how-linux-creates-sockets/#sockets-and-resource-limits">Sockets and resource limits</a></li>
<li><a href="https://ops.tips/blog/how-linux-creates-sockets/#counting-the-number-of-sockets-in-the-system">Counting the number of sockets in the system</a></li>
<li><a href="https://ops.tips/blog/how-linux-creates-sockets/#what-about-namespaces">What about namespaces?</a></li>
<li><a href="https://ops.tips/blog/how-linux-creates-sockets/#closing-thoughts">Closing thoughts</a></li>
<li><a href="https://ops.tips/blog/how-linux-creates-sockets/#resources">Resources</a></li>
</ul>

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<h3 id="what-are-these-sockets-about">What are these sockets about?</h3>

<p>Sockets are the constructs that allow processes on different machines to communicate through an underlying network, being also possibly used as a way of communicating with other processes in the same host (through Unix sockets).</p>

<p>The analogy that really stuck with me is the one presented in the book <a href="https://amzn.to/2DEiNOG" target="_blank"><strong>Computer Networking: A top-down approach</strong></a>.</p>

<p>At a <em>very</em> high-level, we can think of the server machine as this “house” with a set of doors.</p>

<figure class="expanded-container">
  <img width="100%" height="100%" style="max-width: 65rem; " src="./How Linux creates sockets and counts them _ OpsTips_files/house-sockets-overview.svg" alt="A house that represents a server with a door that represents the socket ">

  
</figure>


<p>With each door corresponding to a socket, the client can arrive at the door of the house and “knock” at it.</p>

<p>Right after knocking (sending the <code>SYN</code> packet), the house then automatically responds back with a response (<code>SYN+ACK</code>), which is then acknowledged by the house (yep, smart house with a “smart door”).</p>

<figure class="expanded-container">
  <img width="100%" height="100%" style="max-width: 65rem; " src="./How Linux creates sockets and counts them _ OpsTips_files/client-server-boundary.svg" alt="The interaction between the client and the house when the client is still being greeted by the house ">

  
</figure>


<p>Meanwhile, while the process just sits there within the house, the clients get organized by the “smart house”, which creates two lines: one for those that the house is still greeting, and another one for those that it finished greeting.</p>

<p>Whenever new clients land in the second line, the process can then let it come in.</p>

<figure class="expanded-container">
  <img width="100%" height="100%" style="max-width: 65rem; " src="./How Linux creates sockets and counts them _ OpsTips_files/server-accepting.svg" alt="The server process accepting incoming connections from the two queues formed ">

  
</figure>


<p>Once this connection gets accepted (the client is told to come in), the server is then able to communicate with it, transmitting and receiving data at wish.</p>

<p>One detail to note is that the client doesn’t really “get in” - the server creates a “private door” in the house (a client socket) and then communicates with the client from there.</p>

<div class="ps">

<p>If you’d like to follow the step by step of implementing a TCP server in C, make sure you check this article! <a href="https://ops.tips/blog/a-tcp-server-in-c/"><strong>Implementing a TCP server</strong></a>.</p>

</div>


<h3 id="where-to-look-for-the-list-of-sockets-in-my-system">Where to look for the list of sockets in my system?</h3>

<p>Having the mental model of how the TCP connection establishment looks like, we can now “get into the house” and explore how the machine is creating these “doors” (the sockets), how many doors our house has and in which state they are (are they closed? are they opened?).</p>

<p>For doing so, let’s consider the example of a server that just creates a socket (the door!) and does nothing with it.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// socket.c - creates a socket and then sleeps.
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>

<span class="cm">/**
</span><span class="cm"> * Creates a TCP IPv4 socket and then just
</span><span class="cm"> * waits.
</span><span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// The `socket(2)` syscall creates an endpoint for communication
</span><span class="c1"></span>	<span class="c1">// and returns a file descriptor that refers to that endpoint.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// It takes three arguments (the last being just to provide greater
</span><span class="c1"></span>	<span class="c1">// specificity):
</span><span class="c1"></span>	<span class="c1">// -    domain (communication domain)
</span><span class="c1"></span>	<span class="c1">//      AF_INET              IPv4 Internet protocols
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// -    type (communication semantics)
</span><span class="c1"></span>	<span class="c1">//      SOCK_STREAM          Provides sequenced, reliable,
</span><span class="c1"></span>	<span class="c1">//                           two-way, connection-based byte
</span><span class="c1"></span>	<span class="c1">//                           streams.
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">listen_fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"socket"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>


        <span class="c1">// Just wait ...
</span><span class="c1"></span>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<p>Under the hood, such simple syscall ends up triggering a whole bunch of internal methods (more on that in the next session) that at some point allows us to seek for information about active sockets under three different files: <code>/proc/&lt;pid&gt;/net/tcp</code>, <code>/proc/&lt;pid&gt;/fd</code>, and <code>/proc/&lt;pid&gt;/net/sockstat</code>.</p>

<p>While the <code>fd</code> directory presents us a list of files opened by the process, <code>/proc/&lt;pid&gt;/net/tcp</code> file gives us information regarding currently active TCP connections (in their various states) under the process network namespace. <code>sockstat</code>, on the other hand, acts more like a summary.</p>

<p>Starting with the <code>fd</code> directory, we can see that after the <code>socket(2)</code> call we can see the socket file descriptor in the list of file descriptors:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># Run socket.out (gcc -Wall -o socket.out socket.c)</span>
<span class="c1"># and leave it running in the background</span>
./socket.out <span class="p">&amp;</span>
<span class="o">[</span><span class="m">2</span><span class="o">]</span> <span class="m">21113</span>
 
<span class="c1"># Check out that are the open files that the process has.</span>
ls -lah /proc/21113/fd
dr-x------ <span class="m">2</span> ubuntu ubuntu  <span class="m">0</span> Oct <span class="m">16</span> <span class="m">12</span>:27 .
dr-xr-xr-x <span class="m">9</span> ubuntu ubuntu  <span class="m">0</span> Oct <span class="m">16</span> <span class="m">12</span>:27 ..
lrwx------ <span class="m">1</span> ubuntu ubuntu <span class="m">64</span> Oct <span class="m">16</span> <span class="m">12</span>:27 <span class="m">0</span> -&gt; /dev/pts/0
lrwx------ <span class="m">1</span> ubuntu ubuntu <span class="m">64</span> Oct <span class="m">16</span> <span class="m">12</span>:27 <span class="m">1</span> -&gt; /dev/pts/0
lrwx------ <span class="m">1</span> ubuntu ubuntu <span class="m">64</span> Oct <span class="m">16</span> <span class="m">12</span>:27 <span class="m">2</span> -&gt; /dev/pts/0
lrwx------ <span class="m">1</span> ubuntu ubuntu <span class="m">64</span> Oct <span class="m">16</span> <span class="m">12</span>:27 <span class="m">3</span> -&gt; <span class="s1">'socket:[301666]'</span></code></pre></div>
<p>Given that from a simple call to <code>socket(2)</code> we don’t have a TCP connection, there’s no relevant information to be gathered from <code>/proc/&lt;pid&gt;/net/tcp</code>.</p>

<p>From the summary (<code>sockstat</code>), we can guess that we’re increasing the number of allocated TCP sockets:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># Check the summary regarding socket.</span>
cat /proc/21424/net/sockstat
sockets: used <span class="m">296</span>
TCP: inuse <span class="m">3</span> orphan <span class="m">0</span> tw <span class="m">4</span> alloc <span class="m">106</span> mem <span class="m">1</span>
UDP: inuse <span class="m">1</span> mem <span class="m">0</span>
UDPLITE: inuse <span class="m">0</span>
RAW: inuse <span class="m">0</span>
FRAG: inuse <span class="m">0</span> memory <span class="m">0</span></code></pre></div>
<p>To make sure that we’re really increasing the <code>alloc</code> number, we can modify the source code above and allocate 100 sockets instead:</p>
<div class="highlight"><pre class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+ for (int i = 0; i &lt; 100; i++) {
</span><span class="gi"></span>      int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
      if (err == -1) {
          perror("socket");
          return err;
      }
<span class="gi">+ }
</span></code></pre></div>
<p>Now, checking that again, we can see the <code>alloc</code> at a higher number:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">cat /proc/21456/net/sockstat

                   bigger than before!
                                <span class="p">|</span>
sockets: used <span class="m">296</span>          .----------.
TCP: inuse <span class="m">3</span> orphan <span class="m">0</span> tw <span class="m">4</span> <span class="p">|</span> alloc <span class="m">207</span><span class="p">|</span> mem <span class="m">1</span>
UDP: inuse <span class="m">1</span> mem <span class="m">0</span>         *----------*
UDPLITE: inuse <span class="m">0</span>
RAW: inuse <span class="m">0</span>
FRAG: inuse <span class="m">0</span> memory <span class="m">0</span></code></pre></div>
<p>Now, the question is - how does the socket gets created under the hood?</p>

<h3 id="what-happens-under-the-hood-when-the-socket-syscall-gets-called">What happens under the hood when the socket syscall gets called?</h3>

<p><code>socket(2)</code> is pretty much a factory that produces the underlying structures for handling operations on such socket.</p>

<p>Making use of <a href="https://github.com/iovisor/bcc" target="_blank"><code>iovisor/bcc</code></a>, we can trace the deepest invocation that happens in the <code>sys_socket</code> call stack and from there understand each step.</p>

<pre><code>|  socket()
|--------------- (kernel boundary)
|  sys_socket    
|       (socket, type, protocol)
|  sock_create   
|       (family, type, protocol, res)
|  __sock_create 
|       (net, family, type, protocol, res, kern)
|  sock_alloc    
|       ()
˘
</code></pre>

<p>Starting from <a href="https://elixir.bootlin.com/linux/v4.15/source/net/socket.c#L1317" target="_blank"><code>sys_socket</code></a> itself, this syscall wrapper is the first thing to be touched at kernelspace, being responsible for performing various checks and preparing some flags to pass down to subsequent invocations.</p>

<p>Once preliminary validations have been performed, it allocates in its stack a pointer to a <code>struct socket</code>, the struct that will end up holding the non-protocol specific information about the socket:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Defined `socket` as a syscall with the
</span><span class="cm"> * following arguments:
</span><span class="cm"> * - int family;        - the communication domain
</span><span class="cm"> * - int type; and      - the communication semantics
</span><span class="cm"> * - int protocol.      - a specific protocol within a
</span><span class="cm"> *                        certain domain and semantics.
</span><span class="cm"> *                       
</span><span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> 
        <span class="kt">int</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> 
        <span class="kt">int</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> 
        <span class="kt">int</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">// A pointer that is meant to be pointed to
</span><span class="c1"></span>        <span class="c1">// a `struct sock` that contains the whole
</span><span class="c1"></span>        <span class="c1">// socket definition after it gets properly
</span><span class="c1"></span>        <span class="c1">// allocated by the socket family.
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>


	<span class="c1">// ... Checks some stuff and prepare some flags ...
</span><span class="c1"></span>        <span class="c1">// Create the underlying socket structures.
</span><span class="c1"></span>	<span class="n">retval</span> <span class="o">=</span> <span class="n">sock_create</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>


        <span class="c1">// Allocate the file descriptor for the process so
</span><span class="c1"></span>        <span class="c1">// that it can consume the underlying socket from
</span><span class="c1"></span>        <span class="c1">// userspace.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">sock_map_fd</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">O_CLOEXEC</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**
</span><span class="cm"> * High level wrapper of the socket structures.
</span><span class="cm"> */</span>
<span class="k">struct</span> <span class="n">socket</span> <span class="p">{</span>
	<span class="n">socket_state</span>            <span class="n">state</span><span class="p">;</span>
	<span class="kt">short</span>                   <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span><span class="o">*</span>            <span class="n">sk</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span><span class="o">*</span> <span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span><span class="o">*</span>            <span class="n">file</span><span class="p">;</span>
        <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span></code></pre></div>
<p>Given that at the moment that we create the socket we can choose between different types and protocol families (like, UDP, UNIX, and TCP), the <code>struct socket</code> contains an interface (<code>struct proto_ops*</code>) that defines the basic constructs that sockets implement (regardless of their families/type), which gets initiated on the next method called: <code>sock_create</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Initializes `struct socket`, allocating the
</span><span class="cm"> * necessary memory for it, as well as filling
</span><span class="cm"> * the necessary information associated with
</span><span class="cm"> * the socket.
</span><span class="cm"> * 
</span><span class="cm"> * It:
</span><span class="cm"> * - Performs some argument checking;
</span><span class="cm"> * - Runs a security check hook for `socket_create`
</span><span class="cm"> * - Initializes the actual allocation of the `struct socket`
</span><span class="cm"> *   (letting the `family` do it according to its own rules)
</span><span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__sock_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> 
        <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> 
        <span class="k">struct</span> <span class="n">socket</span> <span class="o">**</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_proto_family</span> <span class="o">*</span><span class="n">pf</span><span class="p">;</span>

        <span class="c1">// Checks if the protocol range.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">family</span> <span class="o">&gt;=</span> <span class="n">NPROTO</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">type</span> <span class="o">&gt;=</span> <span class="n">SOCK_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>


	<span class="c1">// Triggers custom security hooks for socket_create.
</span><span class="c1"></span>	<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_create</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">kern</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>


	 <span class="c1">// Allocates a `struct socket` object and ties it to
</span><span class="c1"></span>         <span class="c1">// a file under the `sockfs` filesystem.
</span><span class="c1"></span>        <span class="n">sock</span> <span class="o">=</span> <span class="n">sock_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">"socket: no more sockets</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>	<span class="cm">/* Not exactly a match, but its the
</span><span class="cm">				   closest posix thing */</span>
	<span class="p">}</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

        <span class="c1">// Tries to retrieve the protocol family methods
</span><span class="c1"></span>        <span class="c1">// for performing the family-specific socket creation.
</span><span class="c1"></span>        <span class="n">pf</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">net_families</span><span class="p">[</span><span class="n">family</span><span class="p">]);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>


        <span class="c1">// Executes the protocol family specific 
</span><span class="c1"></span>        <span class="c1">// socket creation method.
</span><span class="c1"></span>        <span class="c1">//
</span><span class="c1"></span>        <span class="c1">// For instance, if our family is AF_INET (ipv4)
</span><span class="c1"></span>        <span class="c1">// and we're creating a TCP socket (SOCK_STREAM),
</span><span class="c1"></span>        <span class="c1">// a specific method for handling such type of socket
</span><span class="c1"></span>        <span class="c1">// is called.
</span><span class="c1"></span>        <span class="c1">//
</span><span class="c1"></span>        <span class="c1">// If we were specifying a local socket (UNIX),
</span><span class="c1"></span>        <span class="c1">// then another method would be called (given that
</span><span class="c1"></span>        <span class="c1">// such method would implement the `proto_ops` interface
</span><span class="c1"></span>        <span class="c1">// and have been loaded).
</span><span class="c1"></span>	<span class="n">err</span> <span class="o">=</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">kern</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_module_put</span><span class="p">;</span>
        <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<p>Continuing with our deep dive, we can now look closely at how the actual <code>struct socket</code> gets allocated by <code>sock_alloc()</code>.</p>

<figure class="expanded-container">
  <img width="100%" height="100%" style="max-width: 75rem; " src="./How Linux creates sockets and counts them _ OpsTips_files/net-internal-socket.svg" alt="Illustration of how the Linux kernel creates sockets ">

  
</figure>


<p>What that method does is allocate two things: a new <code>inode</code>, and a <code>socket</code> object.</p>

<p>These two are bound together via the <code>sockfs</code> filesystem, which is then responsible for not only keeping track of socket information in the system, but also providing the translation layer between regular filesystem calls (like <code>write(2)</code>) and the network stack (regardless of the underlying communication domain).</p>

<p>By tracing <code>sock_alloc_inode</code>, the method responsible for allocating the inode in <code>sockfs</code>, we’re able to see how that gets set up:</p>
<div class="highlight"><pre class="chroma"><code class="language-cc" data-lang="cc"><span class="n">trace</span> <span class="o">-</span><span class="n">K</span> <span class="n">sock_alloc_inode</span>
<span class="mi">22384</span>   <span class="mi">22384</span>   <span class="n">socket</span><span class="o">-</span><span class="n">create</span><span class="p">.</span><span class="n">out</span>      <span class="n">sock_alloc_inode</span>
        <span class="n">sock_alloc_inode</span><span class="o">+</span><span class="mh">0x1</span> <span class="p">[</span><span class="n">kernel</span><span class="p">]</span>
        <span class="n">new_inode_pseudo</span><span class="o">+</span><span class="mh">0x11</span> <span class="p">[</span><span class="n">kernel</span><span class="p">]</span>
        <span class="n">sock_alloc</span><span class="o">+</span><span class="mh">0x1c</span> <span class="p">[</span><span class="n">kernel</span><span class="p">]</span>
        <span class="n">__sock_create</span><span class="o">+</span><span class="mh">0x80</span> <span class="p">[</span><span class="n">kernel</span><span class="p">]</span>
        <span class="n">sys_socket</span><span class="o">+</span><span class="mh">0x55</span> <span class="p">[</span><span class="n">kernel</span><span class="p">]</span>
        <span class="n">do_syscall_64</span><span class="o">+</span><span class="mh">0x73</span> <span class="p">[</span><span class="n">kernel</span><span class="p">]</span>
        <span class="n">entry_SYSCALL_64_after_hwframe</span><span class="o">+</span><span class="mh">0x3d</span> <span class="p">[</span><span class="n">kernel</span><span class="p">]</span>


<span class="cm">/**
</span><span class="cm"> *	sock_alloc	-	allocate a socket
</span><span class="cm"> *
</span><span class="cm"> *	Allocate a new inode and socket object. The two are bound together
</span><span class="cm"> *	and initialized. The socket is then returned. If we are out of inodes
</span><span class="cm"> *	NULL is returned.
</span><span class="cm"> */</span>
<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>

        <span class="c1">// Given that the filesystem is in-memory,
</span><span class="c1"></span>        <span class="c1">// perform the allocation using the kernel
</span><span class="c1"></span>        <span class="c1">// memory.
</span><span class="c1"></span>	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode_pseudo</span><span class="p">(</span><span class="n">sock_mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>


        <span class="c1">// Retrieves the `socket` struct from
</span><span class="c1"></span>        <span class="c1">// the `inode` that lives in `sockfs`
</span><span class="c1"></span>	<span class="n">sock</span> <span class="o">=</span> <span class="n">SOCKET_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>


        <span class="c1">// Sets some filesystem aspects so that
</span><span class="c1"></span>	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">get_next_ino</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFSOCK</span> <span class="o">|</span> <span class="n">S_IRWXUGO</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">current_fsuid</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">current_fsgid</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sockfs_inode_ops</span><span class="p">;</span>


        <span class="c1">// Update the per-cpu counter (which can then be
</span><span class="c1"></span>        <span class="c1">// used by `sockstat` to and other systems
</span><span class="c1"></span>        <span class="c1">// to quickly know the socket count).
</span><span class="c1"></span>	<span class="n">this_cpu_add</span><span class="p">(</span><span class="n">sockets_in_use</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sock</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">sock_alloc_inode</span><span class="p">(</span>
        <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_alloc</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

        <span class="c1">// Create an entry in the kernel cache 
</span><span class="c1"></span>        <span class="c1">// taking the necessary memory for it.
</span><span class="c1"></span>	<span class="n">ei</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">sock_inode_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">wq</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wq</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">sock_inode_cachep</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

        
        <span class="c1">// Performs the most basic initialization
</span><span class="c1"></span>        <span class="c1">// possible
</span><span class="c1"></span>	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">.</span><span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="c1">// Returns the underlying vfs inode.
</span><span class="c1"></span>	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="sockets-and-resource-limits">Sockets and resource limits</h3>

<p>Given that a filesystem inode can be referred from the userspace from a file descriptor, after we have the underlying Kernel structs all set up, <code>sys_socket</code> is then responsible for generating a file descriptor for the user (going through the resource limits validations as presented in <a href="https://ops.tips/blog/proc-pid-limits-under-the-hood/">Process resource limits under the hood</a>.</p>

<p>If you’ve wondered why it is the case that you might receive a “too many open files” error for <code>socket(2)</code>, that’s the reason - it goes through the same resource limits checks:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span>
<span class="nf">sock_map_fd</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span><span class="o">*</span> <span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span><span class="o">*</span> <span class="n">newfile</span><span class="p">;</span>

        <span class="c1">// Do you recall this one? This is the method
</span><span class="c1"></span>        <span class="c1">// the kernel ends up performing a check against
</span><span class="c1"></span>        <span class="c1">// resource limits and making sure that we don't
</span><span class="c1"></span>        <span class="c1">// get past the limits!
</span><span class="c1"></span>	<span class="kt">int</span>          <span class="n">fd</span> <span class="o">=</span> <span class="n">get_unused_fd_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sock_release</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">newfile</span> <span class="o">=</span> <span class="n">sock_alloc_file</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">newfile</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">newfile</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">newfile</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="counting-the-number-of-sockets-in-the-system">Counting the number of sockets in the system</h3>

<p>If you’ve paid attention to the <a href="https://elixir.bootlin.com/linux/v4.15/source/net/socket.c#L566" target="_blank"><code>sock_alloc</code></a> call, there was a part of it that took care of increasing the number of sockets that are “in-use”.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="nf">sock_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>

        <span class="c1">// ....
</span><span class="c1"></span>
        <span class="c1">// Update the per-cpu counter (which can then be
</span><span class="c1"></span>        <span class="c1">// used by `sockstat` to and other systems
</span><span class="c1"></span>        <span class="c1">// to quickly know the socket count).
</span><span class="c1"></span>	<span class="n">this_cpu_add</span><span class="p">(</span><span class="n">sockets_in_use</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sock</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<p>Being <a href="https://elixir.bootlin.com/linux/v4.15/source/include/linux/percpu-defs.h#L511" target="_blank"><code>this_cpu_add</code></a> a macro, we can look at its definition and understand a bit more about it:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm"> * this_cpu operations (C) 2008-2013 Christoph Lameter &lt;cl@linux.com&gt;
</span><span class="cm"> *
</span><span class="cm"> * Optimized manipulation for memory allocated through the per cpu
</span><span class="cm"> * allocator or for addresses of per cpu variables.
</span><span class="cm"> *
</span><span class="cm"> * These operation guarantee exclusivity of access for other operations
</span><span class="cm"> * on the *same* processor. The assumption is that per cpu data is only
</span><span class="cm"> * accessed by a single processor instance (the current one).
</span><span class="cm"> * 
</span><span class="cm"> * [...]
</span><span class="cm"> */</span></code></pre></div>
<p>Now, given that we’re always adding to <code>sockets_in_use</code>, we can at least guess that if we go through the <a href="https://elixir.bootlin.com/linux/v4.15/source/net/ipv4/proc.c#L54" target="_blank">method that is registered for <code>/proc/net/sockstat</code></a> is going to use that value, which it really does (with also performing an addition over the values registered for each CPU):</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm"> *	Report socket allocation statistics [mea@utu.fi]
</span><span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sockstat_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag_mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orphans</span><span class="p">,</span> <span class="n">sockets</span><span class="p">;</span>

        <span class="c1">// Retrieve the counters related to TCP sockets.
</span><span class="c1"></span>	<span class="n">orphans</span> <span class="o">=</span> <span class="n">percpu_counter_sum_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_orphan_count</span><span class="p">);</span>
	<span class="n">sockets</span> <span class="o">=</span> <span class="n">proto_sockets_allocated_sum_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_prot</span><span class="p">);</span>

        <span class="c1">// Show the stats!
</span><span class="c1"></span>        <span class="c1">// As we saw in the beginning of the article,
</span><span class="c1"></span>        <span class="c1">// `alloc` show all of those that were allocated
</span><span class="c1"></span>        <span class="c1">// and might not be in an "in-use" state yet.
</span><span class="c1"></span>	<span class="n">socket_seq_show</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">"TCP: inuse %d orphan %d tw %d alloc %d mem %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
		   <span class="n">sock_prot_inuse_get</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcp_prot</span><span class="p">),</span> <span class="n">orphans</span><span class="p">,</span>
		   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ipv4</span><span class="p">.</span><span class="n">tcp_death_row</span><span class="p">.</span><span class="n">tw_count</span><span class="p">),</span> <span class="n">sockets</span><span class="p">,</span>
		   <span class="n">proto_memory_allocated</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_prot</span><span class="p">));</span>
	<span class="c1">// ...
</span><span class="c1"></span>	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span>  <span class="s">"FRAG: inuse %u memory %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">!!</span><span class="n">frag_mem</span><span class="p">,</span> <span class="n">frag_mem</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<h3 id="what-about-namespaces">What about namespaces?</h3>

<p>As you might’ve noticed, there’s no logic in the code related to namespaces when it comes to counting how many sockets where allocated.</p>

<p>That’s something that at first really surprised me given that I thought the networking stack was something that was the most namespaced, but it turns out that there are still some points that are not.</p>

<twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1052181698874490880"></twitter-widget>
<script async="" src="./How Linux creates sockets and counts them _ OpsTips_files/widgets.js.tải xuống" charset="utf-8"></script>


<p>If you’d like to see that by yourself, make sure you follow the article <a href="https://ops.tips/blog/using-network-namespaces-and-bridge-to-isolate-servers/"><strong>Using network namespaces and a virtual switch to isolate servers</strong></a>.</p>

<p>The gist of it is that you can create a bunch of sockets, see <code>sockstat</code>, then create a network namespace, get into it, and then see that although you can’t see the TCP sockets from the whole system over there (namespaces in action!), you can see the total number of allocated sockets in the system (not namespaced).</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># Create a bunch of sockets using our</span>
<span class="c1"># example in C</span>
./sockets.out


<span class="c1"># Check that we have a bunch of sockets</span>
cat /proc/net/sockstat
sockets: used <span class="m">296</span>
TCP: inuse <span class="m">5</span> orphan <span class="m">0</span> tw <span class="m">2</span> alloc <span class="m">108</span> mem <span class="m">3</span>
UDP: inuse <span class="m">1</span> mem <span class="m">0</span>
UDPLITE: inuse <span class="m">0</span>
RAW: inuse <span class="m">0</span>
FRAG: inuse <span class="m">0</span> memory <span class="m">0</span>


<span class="c1"># Create a network namespace</span>
ip netns add namespace1


<span class="c1"># Get into it</span>
ip netns <span class="nb">exec</span> namespace1 /bin/bash


<span class="c1"># Check how `/proc/net/sockstat` shows the same</span>
<span class="c1"># number of allocated sockets.</span>
TCP: inuse <span class="m">0</span> orphan <span class="m">0</span> tw <span class="m">0</span> alloc <span class="m">108</span> mem <span class="m">3</span>
UDP: inuse <span class="m">0</span> mem <span class="m">0</span>
UDPLITE: inuse <span class="m">0</span>
RAW: inuse <span class="m">0</span>
FRAG: inuse <span class="m">0</span> memory <span class="m">0</span></code></pre></div>
<h3 id="closing-thoughts">Closing thoughts</h3>

<p>It’s interesting to see how after exploring the inner workings of the Kernel by just being curious about <code>/proc</code> is leading to answers to why some specific behaviors that I’ve seen in daily operations work in such way.</p>

<p>Given that this is just the first article that is about <code>/proc/net</code> and I’ve already learned a lot, I can’t wait to start digging deeper into the rest of it!</p>

<p>If you’d like to follow along with me, make sure you subscribe to the mailing list.</p>

<p>In case you have any questions or thoughts you’d like to share, please let me know!</p>

<p>I’m <a href="https://twitter.com/cirowrc" target="_blank">cirowrc</a> on Twitter, and I’d love to chat with you!</p>

<p>Have a good one,
Ciro</p>

<h3 id="resources">Resources</h3>

<ul>
<li><a href="https://amzn.to/2DEiNOG" target="_blank">Computer Networking: A top-down approach</a>;</li>
<li><a href="https://amzn.to/2QWyXp9" target="_blank">The Linux Programming Interface</a>;</li>
<li><a href="https://amzn.to/2QD0kU4" target="_blank">Understanding the Linux Kernel, 3rd Ed</a>.</li>
</ul>

    </section>
  </article>

</main>

    









        

        
                
        

        

        
                
        

        

        
                
        

        

        
                
        

        

        
                
        

        

        
                
        

        

        
                
        

        

        

        

        
                
        

        

        

        

        
                
        

        

        
                
        

        

        

        

        

        

        
                
        

        

        
                
        

        

        

        

        
                
        

        

        
                
        

        

        
                
        

        

        

        

        
                
        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        
                
        

        

        

        

        
                
        

        

        

        

        
                
        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        

        
                
        

        

        
                
        

        

        

        

        

        

        

        

        

        

        
                
        

        

        
                
        

        

        

        

        

        

        

        

        
                
        

        

        

        

        

        

        

        

        

        

        

        

        



    
                                            



  <section class="recommendation">

    <h3>
    
      Recommended articles
    
    </h3>

    <p>
      If you've gotten some knowledge from this article, these are some others that you might take advatange of as well!
    </p>

    <ul>
      
        <li>
          <a href="https://ops.tips/blog/udp-client-and-server-in-go/">
            A UDP server and client in Go
          </a>
        </li>
      
        <li>
          <a href="https://ops.tips/blog/using-procfs-to-get-process-stack-trace/">
            Using /proc to get a process' current stack trace
          </a>
        </li>
      
        <li>
          <a href="https://ops.tips/blog/proc-pid-limits-under-the-hood/">
            Process resource limits under the hood
          </a>
        </li>
      
        <li>
          <a href="https://ops.tips/blog/a-tcp-server-in-c/">
            Implementing a TCP server in C
          </a>
        </li>
      
        <li>
          <a href="https://ops.tips/blog/raspberry-pi-concourse-ci-worker/">
            A Raspberry PI Concourse Worker
          </a>
        </li>
      
    </ul>
  </section>



    <footer class="footer-cta">
  <div class="container">
    <h3>Stay in touch!</h3>

    <div>
      <p>
        From time to time I'll deliver some content to you.
      </p>
      <p>
        The emails are not automatic - it's all about things I thought were worth sharing that I'd personally like to receive.
      </p>

      <a class="subscribe" href="https://google.us3.list-manage.com/subscribe/post?u=1941019739d6aa1a25eda3787&amp;id=ff9c3cc11e">
        JOIN THE GROUP
      </a>
    </div>

    <p>
      If you're into Twitter, reach me at <a href="https://twitter.com/cirowrc">@cirowrc</a>.
    </p>
  </div>
</footer>

    <footer class="footer">

  <ul>
    <li>
      <a href="https://ops.tips/about">About</a>
    </li>

    <li>
      <a href="https://ops.tips/tags">Tags</a>
    </li>

    <li>
      <a href="https://ops.tips/advertise">Advertise</a>
    </li>

    <li>
      <a href="https://twitter.com/cirowrc">Twitter</a>
    </li>

    <li>
      <a href="https://github.com/cirocosta">GitHub</a>
    </li>

    <li>
      <a href="https://www.linkedin.com/in/cirocosta">LinkedIn</a>
    </li>
  </ul>

  <p>
    © Ciro da Silva da Costa, 2018.
  </p>
</footer>


    





<link rel="stylesheet" href="./How Linux creates sockets and counts them _ OpsTips_files/bundle.min.1582a188dee81ea301c34ff9365e50bd072db13b06b0c8fb76d569d2621945a5.css" integrity="sha256-FYKhiN7oHqMBw0/5Nl5QvQctsTsGsMj7dtVp0mIZRaU=">

    <script async="" src="./How Linux creates sockets and counts them _ OpsTips_files/js"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-109558625-1');
</script>

  

<iframe scrolling="no" frameborder="0" allowtransparency="true" src="./How Linux creates sockets and counts them _ OpsTips_files/widget_iframe.097c1f5038f9e8a0d62a39a892838d66.html" title="Twitter settings iframe" style="display: none;"></iframe><iframe id="rufous-sandbox" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" style="position: absolute; visibility: hidden; display: none; width: 0px; height: 0px; padding: 0px; border: none;" title="Twitter analytics iframe" src="./How Linux creates sockets and counts them _ OpsTips_files/saved_resource.html"></iframe><iframe style="position:absolute;left:-999px;top:-999px;visibility:hidden" src="./How Linux creates sockets and counts them _ OpsTips_files/saved_resource(1).html"></iframe><iframe style="display: none; visibility: hidden;" src="./How Linux creates sockets and counts them _ OpsTips_files/saved_resource(2).html"></iframe></body></html>